#!/usr/bin/perl
use File::Basename;
my $name = basename($0);

if(@ARGV == 0) {
    print <<EOF;
	$name <file1> <file2> [perl-filter-extra-code] [end-of-line-char]

	compare two set of text file; each line is an elment;
        extra filter in perl sintax can be applied to filter 
        input before processed; tipicaly s/regex/new/; 
        empty lines are ignored.

        output is showed in sorted lines with field:
        <this line is present only in file1
        >this line is present only in file2
	-this line is present in both files
	    
	examples:
        raw compare:
           $name myfile1 myfile2 
        avoid spaces at end of lines:
           $name myfile1 myfile2 's/\s+\$//o;'
        ignore all spaces:
           $name myfile1 myfile2 's/\s+//og;'
EOF
    exit(1);
}

$file[0] = shift;
$file[1] = shift;

$filter = shift || '';
$eol = shift || '';

@fh = map { open my $fh, '<', $_  or die "cannot open file $_"; $fh } @file;

sub read_file () {
    my $fh = shift;
    
    my $content = {};
    my $in;
    while(<$fh>) {
	chomp;
	eval ( $filter ) if($filter);
	if($_ ne '') {
	    $content->{$_}++;
	}
    }
    return $content;
}

@content = map { &read_file($_) } @fh;

my $allkeys = {};

foreach my $k (%{$content[0]}) {
    $allkeys->{$k} = $content[0]->{$k};
}
foreach my $k (%{$content[1]}) {
    $allkeys->{$k} += $content[1]->{$k};
}

@format = (' ','*');

# show diff of the two sets:
my $char;
foreach my $k (sort(keys(%{$allkeys}))) {
    $char='<' if ( exists($content[0]->{$k} ));
    $char='>' if ( exists($content[1]->{$k} ));
    $char='-' if ( exists($content[1]->{$k}) && exists($content[0]->{$k} ) );
    print "${char}${k}${eol}\n";
}


map { close($_); } @fg;

