#!/bin/bash

# pegaso-office2text: Wrapper unificato per conversione di documenti Office
# Utilizza pegaso-doc2text per .doc/.docx e pegaso-xls2text per .xls/.xlsx

VERSION="1.0.0"

# Debug mode (set PEGASO_DEBUG=1 to enable)
DEBUG_MODE=${PEGASO_DEBUG:-0}

# Function for debug output
debug_echo() {
    if [[ "$DEBUG_MODE" == "1" ]]; then
        echo "  🔍 Debug: $*" >&2
    fi
}

# Default options
INCLUDE_REJECT_VERSION=false
USE_LIBREOFFICE_FALLBACK=true
EXCEL_FORMAT="md"
SCAN_MODE=false
FILES_TO_PROCESS=()

# Get script directory to find other pegaso tools
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PEGASO_DOC2TEXT="$SCRIPT_DIR/pegaso-doc2text"
PEGASO_XLS2TEXT="$SCRIPT_DIR/pegaso-xls2text"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'    # Cyan instead of blue - better visibility on dark backgrounds
MAGENTA='\033[0;35m' # Magenta for highlights
NC='\033[0m' # No Color

# Function to show help
show_help() {
    cat << EOF
Usage: $0 [OPTIONS] [FILES/DIRECTORIES...]

Convert Microsoft Office files (.doc/.docx/.xls/.xlsx) to Markdown and/or CSV.
This is a unified wrapper for pegaso-doc2text and pegaso-xls2text.

ARGUMENTS:
  FILES/DIRECTORIES        Specific Office files or directories to process
                          Use '.' to process current directory
                          Supports: .doc, .docx, .xls, .xlsx
                          This parameter is REQUIRED (unless using --scan)

OPTIONS:
  Document conversion options (.doc/.docx):
    --include-reject            Also create reject version (track-changes rejected)
    --no-libreoffice-fallback   Disable LibreOffice fallback for EMF conversion

  Spreadsheet conversion options (.xls/.xlsx):
    --format FORMAT             Output format: md, csv, or both (default: md)
    
  General options:
    --scan                      Scan current directory for all Office files
    --version                   Show version information
    -h, --help                  Show this help message

EXAMPLES:
  $0 .                                    # Process all Office files in current directory
  $0 document.docx spreadsheet.xlsx      # Process specific files
  $0 --include-reject *.docx             # Process .docx with both versions
  $0 --format both *.xlsx                # Convert Excel to both MD and CSV
  $0 --scan                              # Interactive scan mode
  $0 /path/to/office/files/              # Process directory
  $0 --format csv --no-libreoffice-fallback mixed_files/

OUTPUT STRUCTURE:
  md/filename.ext/            One directory per file (with extension)
    |-- filename.md           Main markdown file
    |-- filename.csv          CSV file(s) for Excel (with --format csv/both)
    |-- filename.reject.md    Reject version (Word, with --include-reject)
    |-- media/                Images and media files
    |-- README.md             Index file (Excel files)
    \`-- sheet_name.csv        Individual sheets (Excel files)

SUPPORTED FILE TYPES:
  📄 Word Documents: .doc, .docx → Markdown (+ media extraction)
  📊 Excel Sheets: .xls, .xlsx → Markdown tables and/or CSV files

DEPENDENCIES:
  For Word documents: pandoc, imagemagick, libreoffice (optional)
  For Excel files: python3, pandas (via pegaso-xls2text)

EOF
}

# Function to show version
show_version() {
    echo "pegaso-office2text v$VERSION"
    echo "Wrapper for:"
    if [[ -x "$PEGASO_DOC2TEXT" ]]; then
        echo "  - pegaso-doc2text (found)"
    else
        echo "  - pegaso-doc2text (NOT FOUND)"
    fi
    if [[ -x "$PEGASO_XLS2TEXT" ]]; then
        echo "  - pegaso-xls2text (found)"
    else
        echo "  - pegaso-xls2text (NOT FOUND)"
    fi
}

# Function to check if required tools exist
check_pegaso_tools() {
    local missing_tools=()
    
    if [[ ! -x "$PEGASO_DOC2TEXT" ]]; then
        missing_tools+=("pegaso-doc2text")
    fi
    
    if [[ ! -x "$PEGASO_XLS2TEXT" ]]; then
        missing_tools+=("pegaso-xls2text")
    fi
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        echo -e "${RED}❌ ERROR: Missing required Pegaso tools:${NC}"
        for tool in "${missing_tools[@]}"; do
            echo "   $tool (expected at: $SCRIPT_DIR/$tool)"
        done
        echo "   Make sure these tools are in the same directory as pegaso-office2text"
        exit 1
    fi
}

# Parse command line arguments
if [[ $# -eq 0 ]]; then
    show_help
    exit 1
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        --no-libreoffice-fallback)
            USE_LIBREOFFICE_FALLBACK=false
            shift
            ;;
        --include-reject)
            INCLUDE_REJECT_VERSION=true
            shift
            ;;
        --format|-f)
            if [[ -z "$2" ]] || [[ "$2" == --* ]]; then
                echo -e "${RED}❌ ERROR: --format requires an argument (md|csv|both)${NC}"
                exit 1
            fi
            case "$2" in
                md|csv|both)
                    EXCEL_FORMAT="$2"
                    ;;
                *)
                    echo -e "${RED}❌ ERROR: Invalid format '$2'. Use: md, csv, or both${NC}"
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        --scan|-s)
            SCAN_MODE=true
            shift
            ;;
        --version)
            show_version
            exit 0
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        --*)
            echo -e "${RED}❌ ERROR: Unknown option: $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
        *)
            # Non-option argument - treat as file/directory
            FILES_TO_PROCESS+=("$1")
            shift
            ;;
    esac
done

# Check for required Pegaso tools
check_pegaso_tools

# Function to collect all supported Office files
collect_office_files() {
    local files_list=()
    local doc_files=()
    local excel_files=()
    
    debug_echo "collect_office_files called with SCAN_MODE=$SCAN_MODE"
    debug_echo "FILES_TO_PROCESS: ${FILES_TO_PROCESS[*]}"
    
    if [[ "$SCAN_MODE" == "true" ]]; then
        echo -e "${CYAN}📋 Scanning current directory for Office files...${NC}"
        
        # Find all Office files in current directory
        while IFS= read -r -d '' office_file; do
            files_list+=("$office_file")
        done < <(find . \( -name "*.doc" -o -name "*.docx" -o -name "*.xls" -o -name "*.xlsx" \) -type f -print0)
        
        if [[ ${#files_list[@]} -eq 0 ]]; then
            echo -e "${YELLOW}⚠️  No Office files found in current directory${NC}"
            exit 1
        fi
        
        echo -e "${GREEN}Found ${#files_list[@]} Office file(s):${NC}"
        for i in "${!files_list[@]}"; do
            echo "  $((i+1)). ${files_list[$i]}"
        done
        
        echo ""
        read -p "Process all these files? (y/N): " choice
        case "$choice" in
            [Yy]|[Yy][Ee][Ss])
                echo -e "${GREEN}✓ Processing all files...${NC}"
                ;;
            *)
                echo -e "${YELLOW}Operation cancelled${NC}"
                exit 0
                ;;
        esac
        
    else
        # Check if any files/directories were specified
        if [[ ${#FILES_TO_PROCESS[@]} -eq 0 ]]; then
            echo -e "${RED}❌ ERROR: No files or directories specified!${NC}"
            echo "Use '$0 .' to process current directory, or specify specific files/directories."
            echo "Use '$0 --scan' for interactive mode."
            echo "Use '$0 --help' for usage information."
            exit 1
        fi
        
        # Process specified files/directories
        for item in "${FILES_TO_PROCESS[@]}"; do
            debug_echo "Processing item: $item"
            
            if [[ -f "$item" ]]; then
                # It's a file
                case "${item,,}" in
                    *.doc|*.docx|*.xls|*.xlsx)
                        # Skip temporary files
                        case "$(basename "$item")" in
                            \~\$*)
                                echo -e "${YELLOW}⚠️  Skipping temporary file: $item${NC}"
                                ;;
                            *)
                                files_list+=("$item")
                                ;;
                        esac
                        ;;
                    *)
                        echo -e "${YELLOW}⚠️  Warning: $item is not a supported Office file, skipping${NC}"
                        ;;
                esac
            elif [[ -d "$item" ]]; then
                # It's a directory - find all Office files in it
                echo -e "${CYAN}📁 Processing directory: $item${NC}"
                while IFS= read -r -d '' office_file; do
                    # Skip temporary files
                    case "$(basename "$office_file")" in
                        \~\$*)
                            echo -e "${YELLOW}⚠️  Skipping temporary file: $office_file${NC}"
                            ;;
                        *)
                            files_list+=("$office_file")
                            ;;
                    esac
                done < <(find "$item" \( -name "*.doc" -o -name "*.docx" -o -name "*.xls" -o -name "*.xlsx" \) -type f -print0)
            else
                echo -e "${YELLOW}⚠️  Warning: $item not found, skipping${NC}"
            fi
        done
    fi
    
    if [[ ${#files_list[@]} -eq 0 ]]; then
        echo -e "${RED}❌ No supported Office files found to process!${NC}"
        exit 1
    fi
    
    # Separate files by type
    for file in "${files_list[@]}"; do
        case "${file,,}" in
            *.doc|*.docx)
                doc_files+=("$file")
                ;;
            *.xls|*.xlsx)
                excel_files+=("$file")
                ;;
        esac
    done
    
    echo -e "${GREEN}📊 Found ${#files_list[@]} Office file(s) to process:${NC}"
    [[ ${#doc_files[@]} -gt 0 ]] && echo -e "  📄 Word documents: ${#doc_files[@]}"
    [[ ${#excel_files[@]} -gt 0 ]] && echo -e "  📊 Excel files: ${#excel_files[@]}"
    echo ""
    
    # Return the lists via global variables
    DOC_FILES_LIST=("${doc_files[@]}")
    EXCEL_FILES_LIST=("${excel_files[@]}")
}

# Collect files to process
collect_office_files

# Statistics tracking
declare -i total_files=0
declare -i processed_files=0
declare -i failed_files=0

total_files=$((${#DOC_FILES_LIST[@]} + ${#EXCEL_FILES_LIST[@]}))

echo -e "${CYAN}🚀 Starting conversion of $total_files file(s)...${NC}"
echo ""

# Process Word documents (.doc/.docx)
if [[ ${#DOC_FILES_LIST[@]} -gt 0 ]]; then
    echo -e "${CYAN}📄 Processing ${#DOC_FILES_LIST[@]} Word document(s)...${NC}"
    echo "============================================================"
    
    # Build arguments for pegaso-doc2text
    doc_args=()
    [[ "$INCLUDE_REJECT_VERSION" == "true" ]] && doc_args+=("--include-reject")
    [[ "$USE_LIBREOFFICE_FALLBACK" == "false" ]] && doc_args+=("--no-libreoffice-fallback")
    
    # Add all document files
    doc_args+=("${DOC_FILES_LIST[@]}")
    
    debug_echo "Running pegaso-doc2text with args: ${doc_args[*]}"
    
    # Execute pegaso-doc2text
    if [[ "$DEBUG_MODE" == "1" ]]; then
        echo -e "${YELLOW}🔍 Debug: Executing: $PEGASO_DOC2TEXT ${doc_args[*]}${NC}"
    fi
    
    if "$PEGASO_DOC2TEXT" "${doc_args[@]}"; then
        echo -e "${GREEN}✅ Word documents conversion completed successfully${NC}"
        processed_files=$((processed_files + ${#DOC_FILES_LIST[@]}))
    else
        echo -e "${RED}❌ Some Word documents failed to convert${NC}"
        failed_files=$((failed_files + ${#DOC_FILES_LIST[@]}))
    fi
    
    echo ""
fi

# Process Excel files (.xls/.xlsx)
if [[ ${#EXCEL_FILES_LIST[@]} -gt 0 ]]; then
    echo -e "${CYAN}📊 Processing ${#EXCEL_FILES_LIST[@]} Excel file(s)...${NC}"
    echo "============================================================"
    
    # Build arguments for pegaso-xls2text
    excel_args=()
    excel_args+=("--format" "$EXCEL_FORMAT")
    
    # Add all Excel files
    excel_args+=("${EXCEL_FILES_LIST[@]}")
    
    debug_echo "Running pegaso-xls2text with args: ${excel_args[*]}"
    
    # Execute pegaso-xls2text
    if [[ "$DEBUG_MODE" == "1" ]]; then
        echo -e "${YELLOW}🔍 Debug: Executing: $PEGASO_XLS2TEXT ${excel_args[*]}${NC}"
    fi
    
    if "$PEGASO_XLS2TEXT" "${excel_args[@]}"; then
        echo -e "${GREEN}✅ Excel files conversion completed successfully${NC}"
        processed_files=$((processed_files + ${#EXCEL_FILES_LIST[@]}))
    else
        echo -e "${RED}❌ Some Excel files failed to convert${NC}"
        failed_files=$((failed_files + ${#EXCEL_FILES_LIST[@]}))
    fi
    
    echo ""
fi

# Final summary
echo "============================================================"
echo -e "${CYAN}📋 CONVERSION SUMMARY${NC}"
echo "============================================================"
echo -e "${GREEN}✅ Successfully processed: $processed_files/$total_files files${NC}"
if [[ $failed_files -gt 0 ]]; then
    echo -e "${RED}❌ Failed: $failed_files/$total_files files${NC}"
fi

# Show output structure info
echo ""
echo -e "${CYAN}📁 Output Location:${NC}"
echo "  All converted files are saved in: ./md/"
echo "  Each file gets its own subdirectory: md/filename.ext/"

if [[ ${#DOC_FILES_LIST[@]} -gt 0 ]]; then
    echo -e "${CYAN}📄 Word documents include:${NC}"
    echo "    ├── filename.md           # Main markdown file"
    echo "    ├── media/                # Extracted images"
    [[ "$INCLUDE_REJECT_VERSION" == "true" ]] && echo "    ├── filename.reject.md   # Reject version" 
    [[ "$INCLUDE_REJECT_VERSION" == "true" ]] && echo "    └── media.reject/        # Reject version images"
fi

if [[ ${#EXCEL_FILES_LIST[@]} -gt 0 ]]; then
    echo -e "${CYAN}📊 Excel files include:${NC}"
    echo "    ├── README.md             # Index of all sheets"
    case "$EXCEL_FORMAT" in
        "md")
            echo "    └── sheet_name.md         # Each sheet as markdown"
            ;;
        "csv")
            echo "    └── sheet_name.csv        # Each sheet as CSV"
            ;;
        "both")
            echo "    ├── sheet_name.md         # Each sheet as markdown"
            echo "    └── sheet_name.csv        # Each sheet as CSV"
            ;;
    esac
fi

echo ""

# Exit with appropriate code
if [[ $failed_files -gt 0 ]]; then
    echo -e "${YELLOW}⚠️  Some files failed to convert. Check the output above for details.${NC}"
    exit 1
else
    echo -e "${GREEN}🎉 All files converted successfully!${NC}"
    exit 0
fi
